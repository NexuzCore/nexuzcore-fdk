import os
import multiprocessing


from pathlib import Path

from utils.download import download_file, extract_archive
from utils.execute import run_command_live
from utils.load import load_config

from manager.opkg_builder import build_opkg

from core.logger import success, info, warning, error


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  Host-Tools, die nicht gebaut werden
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HOST_TOOLS = [
    "perl",
    "python3",
    "glib2",
    "pkgconf",
    "device-mapper",
    "libudev",
    "libusb",
    "bash",
    "util-linux",
    "meson",
    "ninja",
    "gpgme",
    "json-glib",
    "libsoup",
    "libdevmapper"
]



# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  Spezielle Host-AbhÃ¤ngigkeiten pro Paket
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
PACKAGE_HOST_DEPS = {
    "fwupd": ["libusb"],
    "lvm2": ["device-mapper"],
    "inxi": ["perl"]
}



# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  Pakete laden + Host-AbhÃ¤ngigkeiten mergen
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def load_all_packages(configs_dir: Path) -> dict:
    packages = {}
    
    # Zuerst Host-Tools als virtuelle Pakete anlegen
    for host_tool in HOST_TOOLS:
        packages[host_tool] = {
            "name": host_tool,
            "version": "host",
            "urls": [],
            "src_dir": "",
            "deps": [],
            "configure": []
        }

    # Jetzt JSON-Pakete laden
    for cfg_file in (configs_dir / "packages").glob("*.json"):
        conf = load_config(cfg_file)

        # Basisabsicherung
        conf.setdefault("deps", [])
        conf.setdefault("configure", [])

        # Paketname muss eindeutig sein
        name = conf["name"]
        if name in packages:
            warning(f"âš ï¸  Ãœberschreibe vorhandenes Paket: {name}")
        packages[name] = conf

        # Host-AbhÃ¤ngigkeiten mergen
        if name in PACKAGE_HOST_DEPS:
            for dep in PACKAGE_HOST_DEPS[name]:
                if dep not in conf["deps"]:
                    conf["deps"].append(dep)

    return packages



# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  AbhÃ¤ngigkeitsauflÃ¶sung
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def resolve_build_order(packages: dict) -> list[str]:
    visited, order = {}, []

    def visit(name: str):
        if name in visited:
            if visited[name] == "temp":
                raise RuntimeError(f"ZirkulÃ¤re AbhÃ¤ngigkeit entdeckt bei {name}")
            return
        visited[name] = "temp"
        for dep in packages[name].get("deps", []):
            if dep not in packages:
                raise RuntimeError(f"Unbekannte AbhÃ¤ngigkeit {dep} fÃ¼r Paket {name}")
            visit(dep)
        visited[name] = "perm"
        order.append(name)

    for pkg in packages:
        visit(pkg)

    return order



# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  Generischer Builder
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  Generischer Builder mit GCC Multilib-Fix
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def generic_builder(args, conf, work_dir: Path, downloads_dir: Path, rootfs_dir: Path):
    """ Generic Build Function with GCC Multilib Fix"""
    
    name = conf["name"]
    
    # Spezielle Behandlung fÃ¼r opkg
    if name == "opkg":
        build_opkg(args, conf, work_dir, downloads_dir, rootfs_dir)
        return True  # Build abgeschlossen
    
    # Host-Tool-Check
    if conf.get("version") == "host":
        info(f"âš¡ {conf['name']} ist ein Host-Tool, Ã¼berspringe Build.")
        return True  # erfolgreich "gebaut"

    name = conf["name"]
    version = conf["version"]
    src_dir = Path(conf["src_dir"].format(version=version))

    info(f"\n=== Baue Paket: {name} {version} ===")

    
    # Download & Entpacken
    tarball = download_file(conf["urls"], downloads_dir)
    extract_archive(tarball, work_dir)
    info(f"ğŸ“‚ Quellverzeichnis: {src_dir}")

    # Architektur-Setup
    arch = args.arch if args.arch else "x86_64"
    env = os.environ.copy()

    if arch in ("x86_64", "amd64"):
        host = "x86_64-linux-gnu"
        env["CC"] = "gcc"
        env["CXX"] = "g++"
        arch_str = "x86_64"
    elif arch in ("arm64", "aarch64"):
        host = "aarch64-linux-gnu"
        env["CC"] = "aarch64-linux-gnu-gcc"
        env["CXX"] = "aarch64-linux-gnu-g++"
        arch_str = "aarch64"
    else:
        raise RuntimeError(f"Unsupported architecture: {arch}")


    # Configure
    if conf.get("configure"):
        # JSON liefert eigene Configure-Kommandos
        cmd = [part.replace("{arch}", arch_str).replace("{rootfs}", str(rootfs_dir)) for part in conf["configure"]]
        run_command_live(cmd, cwd=src_dir, env=env, desc=f"{name}: custom configure")
    else:
        configure_script = src_dir / "configure"
        cmake_file = src_dir / "CMakeLists.txt"

        if configure_script.exists():
            cmd = ["./configure", f"--host={host}", "--prefix=/usr"]

            # Automatisch --disable-multilib fÃ¼r gcc hinzufÃ¼gen
            if name == "gcc":
                cmd.append("--disable-multilib")

            run_command_live(cmd, cwd=src_dir, env=env, desc=f"{name}: configure")
        elif cmake_file.exists():
            build_dir = src_dir / "build"
            build_dir.mkdir(exist_ok=True)
            cmd = [
                "cmake", "..",
                f"-DCMAKE_INSTALL_PREFIX=/usr",
                f"-DCMAKE_BUILD_TYPE=Release",
                f"-DCMAKE_C_COMPILER={env['CC']}",
                f"-DCMAKE_CXX_COMPILER={env['CXX']}"
            ]
            run_command_live(cmd, cwd=build_dir, env=env, desc=f"{name}: cmake configure")
        else:
            warning(f"âš ï¸ Kein configure/CMakeLists.txt gefunden â€“ Ã¼berspringe configure.")
            build_dir = src_dir


    # Build & Install
    num_cores = multiprocessing.cpu_count()
    make_dir = build_dir if 'build_dir' in locals() else src_dir
    
    run_command_live(["make", f"-j{num_cores}"], cwd=make_dir, env=env, desc=f"{name}: build")
    run_command_live(["make", f"DESTDIR={rootfs_dir}", "install"], cwd=make_dir, env=env, desc=f"{name}: install")

    success(f"âœ… {name} {version} erfolgreich installiert in {rootfs_dir}")



# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  Alle Pakete in AbhÃ¤ngigkeitsreihenfolge bauen
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def build_all_packages_from_source(args, configs_dir: Path, work_dir: Path, downloads_dir: Path, rootfs_dir: Path):
    packages = load_all_packages(configs_dir)
    build_order = resolve_build_order(packages)
    info(f"ğŸ“¦ Build-Reihenfolge: {', '.join(build_order)}")

    failed = []

    for name in build_order:
        conf = packages[name]
        try:
            generic_builder(args, conf, work_dir, downloads_dir, rootfs_dir)
        except Exception as e:
            error(f"âŒ Fehler beim Bauen von {name}: {e}")
            failed.append(name)
            if not getattr(args, "ignore_errors", False):
                raise
            else:
                warning("â¡ï¸  Ignoriere Fehler und fahre mit dem nÃ¤chsten Paket fort.")
    
    if failed:
        error("\nâš ï¸ Folgende Pakete konnten nicht gebaut werden:")
        for n in failed:
            error(f"  - {n}")
            
    else:
        success("\nâœ… Alle Pakete erfolgreich gebaut!")
        

